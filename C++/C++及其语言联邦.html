<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第一部分 C++基础语法 | y1s1_blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    
    <meta name="description" content="This is a personal blog.">
    
    <link rel="preload" href="/y1s1_blog/assets/css/0.styles.b4d20533.css" as="style"><link rel="preload" href="/y1s1_blog/assets/js/app.232c4f74.js" as="script"><link rel="preload" href="/y1s1_blog/assets/js/2.2dc00104.js" as="script"><link rel="preload" href="/y1s1_blog/assets/js/7.bd043cd8.js" as="script"><link rel="prefetch" href="/y1s1_blog/assets/js/10.af1e9fa8.js"><link rel="prefetch" href="/y1s1_blog/assets/js/11.0863937c.js"><link rel="prefetch" href="/y1s1_blog/assets/js/12.2361b6db.js"><link rel="prefetch" href="/y1s1_blog/assets/js/13.c702ce9a.js"><link rel="prefetch" href="/y1s1_blog/assets/js/14.7fe6a023.js"><link rel="prefetch" href="/y1s1_blog/assets/js/15.94d05282.js"><link rel="prefetch" href="/y1s1_blog/assets/js/16.9662623c.js"><link rel="prefetch" href="/y1s1_blog/assets/js/3.5e04ea21.js"><link rel="prefetch" href="/y1s1_blog/assets/js/4.7b6dc275.js"><link rel="prefetch" href="/y1s1_blog/assets/js/5.4f56dc33.js"><link rel="prefetch" href="/y1s1_blog/assets/js/6.72ad7c85.js"><link rel="prefetch" href="/y1s1_blog/assets/js/8.e325631f.js"><link rel="prefetch" href="/y1s1_blog/assets/js/9.3600b428.js">
    <link rel="stylesheet" href="/y1s1_blog/assets/css/0.styles.b4d20533.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/y1s1_blog/" class="home-link router-link-active"><!----> <span class="site-name">y1s1_blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/y1s1_blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/y1s1_blog/C++/" class="nav-link router-link-active">
  C++
</a></div><div class="nav-item"><a href="/y1s1_blog/算法/" class="nav-link">
  算法
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机基础" class="mobile-dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/y1s1_blog/计算机基础/计算机网络.html" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/y1s1_blog/计算机基础/操作系统.html" class="nav-link">
  操作系统
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程实践" class="dropdown-title"><span class="title">编程实践</span> <span class="arrow down"></span></button> <button type="button" aria-label="编程实践" class="mobile-dropdown-title"><span class="title">编程实践</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/y1s1_blog/C++/编程实践/基础练习.html" class="nav-link">
  基础练习
</a></li><li class="dropdown-item"><!----> <a href="/y1s1_blog/编程实践/设计模式.html" class="nav-link">
  设计模式
</a></li><li class="dropdown-item"><!----> <a href="/y1s1_blog/编程实践/QT学习笔记.html" class="nav-link">
  Qt开发
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其他" class="dropdown-title"><span class="title">其他</span> <span class="arrow down"></span></button> <button type="button" aria-label="其他" class="mobile-dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/y1s1_blog/C++/README.html" class="nav-link">
  我自己
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/buhuangchiyao" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/y1s1_blog/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/y1s1_blog/C++/" class="nav-link router-link-active">
  C++
</a></div><div class="nav-item"><a href="/y1s1_blog/算法/" class="nav-link">
  算法
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="计算机基础" class="dropdown-title"><span class="title">计算机基础</span> <span class="arrow down"></span></button> <button type="button" aria-label="计算机基础" class="mobile-dropdown-title"><span class="title">计算机基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/y1s1_blog/计算机基础/计算机网络.html" class="nav-link">
  计算机网络
</a></li><li class="dropdown-item"><!----> <a href="/y1s1_blog/计算机基础/操作系统.html" class="nav-link">
  操作系统
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="编程实践" class="dropdown-title"><span class="title">编程实践</span> <span class="arrow down"></span></button> <button type="button" aria-label="编程实践" class="mobile-dropdown-title"><span class="title">编程实践</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/y1s1_blog/C++/编程实践/基础练习.html" class="nav-link">
  基础练习
</a></li><li class="dropdown-item"><!----> <a href="/y1s1_blog/编程实践/设计模式.html" class="nav-link">
  设计模式
</a></li><li class="dropdown-item"><!----> <a href="/y1s1_blog/编程实践/QT学习笔记.html" class="nav-link">
  Qt开发
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="其他" class="dropdown-title"><span class="title">其他</span> <span class="arrow down"></span></button> <button type="button" aria-label="其他" class="mobile-dropdown-title"><span class="title">其他</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/y1s1_blog/C++/README.html" class="nav-link">
  我自己
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/buhuangchiyao" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>第一部分 C++基础语法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/y1s1_blog/C++/C++%E5%8F%8A%E5%85%B6%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6.html#第一部分-c-基础语法" class="sidebar-link">第一部分 C++基础语法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/y1s1_blog/C++/C++%E5%8F%8A%E5%85%B6%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6.html#_1-预处理器" class="sidebar-link">1. 预处理器</a></li><li class="sidebar-sub-header"><a href="/y1s1_blog/C++/C++%E5%8F%8A%E5%85%B6%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6.html#_2-基本内置类型" class="sidebar-link">2. 基本内置类型</a></li><li class="sidebar-sub-header"><a href="/y1s1_blog/C++/C++%E5%8F%8A%E5%85%B6%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6.html#_3-常量和变量" class="sidebar-link">3. 常量和变量</a></li><li class="sidebar-sub-header"><a href="/y1s1_blog/C++/C++%E5%8F%8A%E5%85%B6%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6.html#_4-复合类型" class="sidebar-link">4. 复合类型</a></li><li class="sidebar-sub-header"><a href="/y1s1_blog/C++/C++%E5%8F%8A%E5%85%B6%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6.html#_5-流程控制语句" class="sidebar-link">5. 流程控制语句</a></li><li class="sidebar-sub-header"><a href="/y1s1_blog/C++/C++%E5%8F%8A%E5%85%B6%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6.html#_6-运算符" class="sidebar-link">6. 运算符</a></li><li class="sidebar-sub-header"><a href="/y1s1_blog/C++/C++%E5%8F%8A%E5%85%B6%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6.html#_7-const限定符" class="sidebar-link">7. const限定符</a></li><li class="sidebar-sub-header"><a href="/y1s1_blog/C++/C++%E5%8F%8A%E5%85%B6%E8%AF%AD%E8%A8%80%E8%81%94%E9%82%A6.html#_8-函数" class="sidebar-link">8.函数</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="第一部分-c-基础语法"><a href="#第一部分-c-基础语法" class="header-anchor">#</a> 第一部分 C++基础语法</h2> <h3 id="_1-预处理器"><a href="#_1-预处理器" class="header-anchor">#</a> 1. 预处理器</h3> <ul><li>作用：确保头文件多次包含仍能安全工作。</li> <li>功能：
<ol><li>预处理符：<code>#include</code> 当预处理器看到<code>#inlcude</code>时，用指定头文件代替。</li> <li>头文件保护符：依赖于预处理变量。</li></ol> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">SALES_DATA_H</span>     <span class="token comment">//把一个名字设定为预处理变量</span></span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span>  <span class="token expression">SALES_DATA_H     </span><span class="token comment">//当且仅当变量已定义时为真</span></span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span>                  <span class="token comment">//变量未定义时为真</span></span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span>                   <span class="token comment">//预处理结束</span></span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li> <li>使用：
<ol><li>预处理无视C++语言关于作用域的规则。</li> <li>一般预处理的变量名字全部大写。</li> <li>头文件即使没有被包含在任何其他头文件中，也应该设置保护符。</li></ol></li> <li>预处理变量不属于命名空间std，由预处理器负责管理。</li> <li>当用到一个预处理变量时，预处理器会自动将它替换为实际值。</li></ul> <h3 id="_2-基本内置类型"><a href="#_2-基本内置类型" class="header-anchor">#</a> 2. 基本内置类型</h3> <ul><li>算术类型(bool,char,short,int,long,long long,float,double,long double)。</li> <li>带符号类型和无符号类型（unsigned）。</li> <li>1字=4字节=32比特
<h4 id="类型转换-❤❤❤"><a href="#类型转换-❤❤❤" class="header-anchor">#</a> 类型转换（❤❤❤）</h4> <ol><li>非布尔类型的算术值赋给布尔类型时：初始值为0，则结果为false；否则，结果为true。</li> <li>浮点数赋值给整数类型时：仅保留小数点前的部分。</li> <li>整数赋值给浮点数时：小数点后为0.</li> <li>给无符号类型赋一个超出它表示范围的值时，结果是初始值对无符号类型表示数值取模后的余数。（带符号类型和未带符号类型不能混用）</li> <li>赋值给带符号类型一个超出自身范围的值时，结果是未定义的。</li></ol></li></ul> <h3 id="_3-常量和变量"><a href="#_3-常量和变量" class="header-anchor">#</a> 3. 常量和变量</h3> <h4 id="字面值常量"><a href="#字面值常量" class="header-anchor">#</a> 字面值常量</h4> <ul><li>整型和浮点字面值
<ul><li>整型字面值：八进制（以0开头），十进制，十六进制（以0X或0x开头）。</li> <li>整型字面值的数据类型由值和符号决定。（数据类型为尺寸最小的那个）</li> <li>short没有对应的字面值</li> <li>浮点数字面值：一个小数或以科学计数法表示的指数。指数部分用E或e标识。</li></ul></li> <li>字符和字符串字面值
<ul><li>字符：单引号括起来的一个字符称为char型字面值、</li> <li>字符串：双引号括起来的零个或多个字符。实际上是由常量字符构成的数组。</li></ul></li> <li>转义序列
<ul><li>“翻译”一些不能直接使用的字符：
<ol><li>不可打印的字符，如退格或其他控制字符</li> <li>有特殊含义的字符，如单引号，双引号，问号，反斜线</li></ol></li></ul></li> <li>指定字面值的数据类型
<ul><li>通过添加前缀和后缀，可以改变整形、浮点型和字符型字面值的默认类型。</li></ul></li> <li>布尔字面值和指针字面值
<ul><li>bool类型的字面值为：true和false</li> <li>nullptr是指针字面值（C++❤）</li> <li>NULL是另一个指针字面值。
<h4 id="nullptr和null的区别-❤❤❤"><a href="#nullptr和null的区别-❤❤❤" class="header-anchor">#</a> nullptr和NULL的区别（❤❤❤）</h4> <ol><li>NULL和nullptr都用来将指针初始化为字面值0来生成空指针。</li> <li>NULL是一个<strong>预处理变量</strong>，这个变量定义在头文件cstdlib中。</li> <li>NULL在调用时可能会出现二义性的错误。</li> <li>现在的C++程序最好使用nullptr，避免使用NULL来初始化空指针。</li></ol></li></ul></li></ul> <h4 id="变量"><a href="#变量" class="header-anchor">#</a> 变量</h4> <ul><li><p>什么是变量、数据类型、对象？</p> <ol><li>变量提供一个<strong>具名的</strong>、可供程序操作的<strong>存储空间</strong>;</li> <li>C++中的每个变量都有其<strong>数据类型</strong>，数据类型决定着所占内存空间的大小和布局方式、该空间能存储的值的范围，以及变量能参与的运算;</li> <li>对象是指一块能存储数据并且具有某种类型的内存空间。</li> <li>“变量”和“对象”一般可以交换使用。</li></ol></li> <li><p>变量的初始化与赋值（❤❤❤）</p> <ul><li>初始化和赋值是两个完全不同的操作。</li> <li>初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值。</li> <li>赋值是把对象的当前值擦除，而以一个新值来替代</li> <li></li></ul></li> <li><p>默认初始化</p> <ul><li>当定义变量时没有指定初值，则变量被默认初始化。</li> <li>对于内置数据类型：定义于任何函数体外的变量初始化为0；定义在函数体内部的内置变量将不被初始化。</li> <li>对于类的对象，如果没有显式初始化，其值由类决定。</li> <li>一个未初始化变量（类）的值是未定义的，如果试图访问将引发错误。</li></ul></li> <li><p>变量声明和变量定义（❤❤❤）</p> <ul><li>C++语言支持分离式编译机制：允许将程序分割为若干个文件，每个文件可被独立编译。</li> <li>声明：使得名字为程序所知。规定了变量的类型和名字。</li> <li>定义：负责创建与名字关联的实体。规定变量的类型和名字，<strong>申请存储空间</strong>，可能会为变量赋一个<strong>初始值</strong>。</li> <li>声明一个变量使用***extern***关键字，而且不能显示初始化。</li> <li>变量能且只能被定义一次，但是可以被多次声明。</li></ul></li> <li><p>作用域</p> <ul><li>全局作用域</li> <li>块作用域</li></ul></li></ul> <h3 id="_4-复合类型"><a href="#_4-复合类型" class="header-anchor">#</a> 4. 复合类型</h3> <ul><li><h4 id="引用"><a href="#引用" class="header-anchor">#</a> 引用</h4> <ul><li>引用的用法<div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> ival <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">&amp;</span>refVal <span class="token operator">=</span> ival<span class="token punctuation">;</span>       <span class="token comment">//refVal指向ival</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li>引用的含义（❤❤❤）
<ul><li>引用并非对象（变量），它是为一个已经存在的对象所起的另一个名字（<strong>引用即别名</strong>）。</li> <li>定义引用时，程序把引用和它的初始值<strong>绑定</strong>在一起，而不是将初始值拷贝给引用</li> <li>引用只能绑定在对象上，而不能与字面值或某个表达式的计算结果绑定在一起。</li> <li>引用一旦和他的初始化对象绑定在一起，就<strong>无法重新绑定</strong>给另外一个对象。所以引用必须初始化。</li> <li>引用的对象要和初始化对象的类型<strong>严格匹配</strong>。</li></ul></li></ul></li> <li><h4 id="指针"><a href="#指针" class="header-anchor">#</a> 指针</h4> <ul><li><p>指针的含义</p> <ul><li>指针本身是一个对象，而且是指向另外一个对象地址的复合类型。允许对指针赋值和拷贝。</li> <li>指针无须在定义时赋值。</li></ul></li> <li><p>操作指针对象的操作符</p> <ul><li>取地址符（&amp;）：获取指针存放对象的地址。</li> <li>解引用符（*）：访问指针所指的对象，仅适用于指向了某个对象的有效指针。</li></ul></li> <li><p>指针值的4种状态</p> <ol><li>指向一个对象</li> <li>指向紧邻对象所占空间的下一个位置（尾迭代器）</li> <li>空指针，没有指向任何对象</li> <li>无效指针，上述情况之外的其他值</li></ol></li> <li><p>空指针（不指向任何对象的指针）</p> <ul><li>空指针的生成方式</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token operator">*</span>p1<span class="token operator">=</span><span class="token keyword">nullptr</span><span class="token punctuation">;</span>              <span class="token comment">//C++新特性，推荐使用</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token comment">//直接初始化为字面常量0</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p3 <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>               <span class="token comment">//预处理变量，需要#include&lt;cstdlib&gt;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>建议初始化所有的指针，对于不知道指向何处的指针，初始化为nullptr。</li></ul></li> <li><p>指针的赋值：令他存放一个新的地址，从而指向一个新的对象。</p> <p><em><strong>tips</strong></em>：赋值永远改变的是等号左侧的对象。</p></li> <li><p>指针的其他操作</p> <ul><li>指针的bool值：如果指针的值为0，bool值为false；任何非0指针相应的bool值都为true。</li> <li>指针的相等（==）和不等（！=）操作：如果两个指针存放的<strong>地址值</strong>相等，则它们相等；反之不等。</li> <li>地址值相等包括：都为空、都指向同一对象、都指向了同一个对象的下一个地址。</li></ul></li> <li><p>void*指针</p> <ul><li>是一种特殊的指针类型，可用于存放任意对象的地址</li> <li>void* 指针允许的操作：拿它和别的指针比较；作为函数的输入或输出；或者赋给另外一个void*指针。</li> <li>不能直接操作void*指针所指的对象。</li></ul></li></ul></li> <li><h4 id="理解复合类型"><a href="#理解复合类型" class="header-anchor">#</a> 理解复合类型</h4> <ul><li>复合类型是指基于其他类型定义的类型，复合类型的声明包括<strong>类型修饰符</strong>和<strong>基本数据类型</strong>。</li> <li>定义多个变量的两种形式<div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code> <span class="token keyword">int</span> <span class="token operator">*</span>p1<span class="token punctuation">,</span> <span class="token operator">*</span>p2<span class="token punctuation">;</span>             <span class="token comment">//强调变量具有的复合类型</span>
 <span class="token keyword">int</span><span class="token operator">*</span> p1<span class="token punctuation">;</span> <span class="token keyword">int</span><span class="token operator">*</span> p2<span class="token punctuation">;</span>         <span class="token comment">//强调本次声明定义了一种复合类型（推荐）</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div>两种形式无优劣之分，应选用一种。</li> <li>指向指针的指针
<ul><li>指针是内存中的对象，在内存中拥有自己的地址。因此允许定义一个指向指针的指针(<code>int** p1</code>)；</li> <li>对于指向指针的指针，为了访问最原始的对象，需要对指针的指针做两次解引用。</li></ul></li></ul></li> <li><h4 id="内置数组"><a href="#内置数组" class="header-anchor">#</a> 内置数组</h4> <ul><li>特点：存放类型相同的对象的容器；这些对象没有名字，通过所在位置访问；数组的大小确定不变，不能随意增加元素。</li> <li>定义和初始化内置数组：
<ul><li>数组的声明：形如a[d],其中 a 是数组的名字，d 是数组的维度。 维度说明了数组中元素的个数， 元素的个数也属于数组类型的一部分。维度必须是一个常量表达式。</li> <li>不允许用auto关键字由初始值的列表推断数组类型。</li> <li>数组的的元素应为对象，因此不存在引用的数组。</li> <li>显示初始化数组元素：如果指明了维度，那么初始值的总数量不应该超出指定的大小； 维度比提供的初始值数量大，则用提供的初始值初始化靠前的元素，剩下的元素被初始化为默认值。</li> <li>字符数组的特殊性</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>  <span class="token keyword">char</span> a1<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token string">'+'</span><span class="token punctuation">,</span><span class="token string">'+'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>          <span class="token comment">//列表初始化，没有空字符</span>
  <span class="token keyword">char</span> a2<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token string">'c'</span><span class="token punctuation">,</span><span class="token string">'+'</span><span class="token punctuation">,</span><span class="token string">'+'</span><span class="token punctuation">,</span><span class="token string">'\0'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token comment">//列表初始化，含有显示的空字符</span>
  <span class="token keyword">char</span> a3<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">&quot;c++&quot;</span><span class="token punctuation">;</span>                  <span class="token comment">//自动添加表示字符串结束的空字符</span>
  <span class="token keyword">char</span> a4<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string">&quot;Daniel&quot;</span><span class="token punctuation">;</span>              <span class="token comment">//错误：没有空间存放空字符</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值。</li> <li>理解复杂的数组声明<div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>  <span class="token keyword">int</span> <span class="token operator">*</span>ptrs<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment">//ptrs是含有10个整型指针的数组</span>
  <span class="token keyword">int</span> <span class="token operator">&amp;</span>refs<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment">//错误：不存在引用的指针</span>
  <span class="token comment">//Parray是一个指针，它指向一个int数组，数组中包含10个元素</span>
  <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span>Parray<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">&amp;</span>arr<span class="token punctuation">;</span>       <span class="token comment">//Parray指向一个含有10个整数的数组</span>
  <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>arrRef<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">;</span>        <span class="token comment">//arrRef引用一个含有10个整数的数组</span>
  <span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>arry<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token operator">=</span>ptrs<span class="token punctuation">;</span>        <span class="token comment">//arry是数组的引用，该数组含有10个指针</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li></ul></li> <li>访问数组元素
<ul><li>数组的元素能使用下标运算符和范围<strong>for语句</strong>访问。</li> <li>数组的下标为size_t类型。</li> <li>检查下标是否合理：下标大于等于0而且小于数组的大小。</li></ul></li> <li>指针和数组
<ul><li>数组名是一个指向数组首元素的指针。</li> <li>数组指针可以进行迭代器的所有操作。</li> <li>数组可以获取尾后指针，但是不能执行解引用或递增操作。</li> <li>数组的标准库函数begin和end<div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> ia<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">}</span><span class="token punctuation">;</span>         <span class="token comment">//ia是一个整数数组</span>
<span class="token keyword">int</span> <span class="token operator">*</span>beg<span class="token operator">=</span><span class="token function">begin</span><span class="token punctuation">(</span>ia<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment">//指向ia首元素的指针</span>
<span class="token keyword">int</span> <span class="token operator">*</span>end<span class="token operator">=</span><span class="token function">end</span><span class="token punctuation">(</span>ia<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">//指向ia尾元素的下一位置的指针</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>begin函数返回指向ia首元素的指针。</li> <li>end函数返回指向ia尾元素下一位置的指针。</li></ul></li></ul></li> <li>数组指针运算
<ul><li>一个指针加上（减去）某整数值，结果仍是指针。新指针指向的元素与原来的指针相比前进了（后退了）该整数值个位置。</li> <li>给指针加上一个整数，得到的新指针仍需指向同一数组的其他元素，或者指向数组尾元素的下一位置。</li> <li>两个指针相减的结果是他们之间的距离。有可能为负。</li> <li>如果两个指针分别指向不相关的对象，则不能比较它们。</li></ul></li></ul></li> <li><p>C风格字符串</p> <ul><li>字符串字面值</li></ul></li></ul> <h4 id="引用和指针的区别-❤❤❤❤"><a href="#引用和指针的区别-❤❤❤❤" class="header-anchor">#</a> 引用和指针的区别（❤❤❤❤）</h4> <table><thead><tr><th>指针</th> <th>引用</th></tr></thead> <tbody><tr><td>是一个对象</td> <td>对象的一个别名</td></tr> <tr><td>自己的内存空间</td> <td>和变量占用同一内存空间</td></tr> <tr><td>可以改变所指对象</td> <td>初始化后不能改变</td></tr> <tr><td>存在空值指针</td> <td>必须初始化</td></tr> <tr><td>sizeof(引用) 得到所指向对象的大小</td> <td>sizeof(指针) 返回4</td></tr> <tr><td>没有const</td> <td>有const指针</td></tr></tbody></table> <ul><li>都可以作为<strong>函数参数</strong>。引用的主要作用是传递函数的参数和返回值，作为参数传递时，指针需要被解引用才可以对对象进行操作，而直接对引用的修改都会改变引用所指向的对象；</li> <li>当不需要改变指向时，引用优于指针。</li></ul> <h3 id="_5-流程控制语句"><a href="#_5-流程控制语句" class="header-anchor">#</a> 5. 流程控制语句</h3> <h4 id="简单语句"><a href="#简单语句" class="header-anchor">#</a> 简单语句</h4> <ul><li>空语句
<ul><li>定义：只含有一个单独分号的语句。</li> <li>表示一条逻辑上不需要，但是<strong>语法</strong>上需要的语句。</li> <li>使用空语句时应该加上<strong>注释</strong>。</li> <li>多余的空语句并不是都是无害的，不能多写分号。也不能漏写分号。</li></ul></li> <li>块语句（复合语句）
<ul><li>定义：用花括号括起来的语句和声明序列。</li> <li>表示语法上需要一条语句，但是逻辑上需要多条语句。</li> <li>块语句不以分号结束。</li></ul></li> <li>语句作用域
<ul><li>在if、switch、for语句的控制结构内定义的变量，只能在相应的语句内部可见。</li> <li>在控制结构内定义的变量要马上使用，所以必须初始化。</li> <li>如果其他代码要访问控制结构内的控制变量，则变量必须定义在语句的外部。</li></ul></li></ul> <h4 id="条件语句"><a href="#条件语句" class="header-anchor">#</a> 条件语句</h4> <ul><li>if语句<div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>  <span class="token keyword">if</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span>
    statement           <span class="token comment">//if语句</span>

  <span class="token keyword">if</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span>
    statement1      
  <span class="token keyword">else</span>
    statement2        <span class="token comment">//if-else语句</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>condition：必须用圆括号包围起来；可以是一个表达式，也可以是一个可以转化为bool类型的变量声明。</li> <li>当condition为真时执行statement语句，否则跳过。</li> <li>if-else语句可以嵌套使用，为了避免statement语句缩进问题：在if或else之后必须写上花括号</li> <li>else与离它最近的尚未匹配的if匹配。</li></ul></li> <li>switch语句<div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>  <span class="token keyword">switch</span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">case</span>  constant<span class="token operator">-</span>expression <span class="token operator">:</span> statement1<span class="token punctuation">;</span>         <span class="token comment">//case关键字和它对应的constant-expression值一起被称为case标签</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>                                          <span class="token comment">//break语句的作用是中断当前的控制流</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">default</span><span class="token operator">:</span>                                        <span class="token comment">//没有能与expression匹配的case标签是，执行default标签的statement</span>
    statement<span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li>switch语句内部的控制流：
<ul><li>如果expression和某个case标签匹配成功，程序从该标签之后的第一条语句开始执行，直到到达了switch的结尾或者是遇到一条break语句为止。</li> <li>想要避免执行后续case分支的代码，我们必须显示在下一个case标签前添加一条break语句。</li> <li>当我们希望两个或者多个case标签<strong>共享</strong>同一组操作时，我们故意<strong>省略</strong>掉break语句，使得程序连续执行若干个case标签。</li></ul></li> <li>当省略case分支最后的break语句时，最好加一段注释说明。</li> <li>即使不准备在default标签下做任何工作，也应该定义一个default标签。</li> <li>switch内部的<strong>变量定义</strong> <ul><li>如果需要为某个case分支定义并初始化一个变量，应该把变量定义在<em><strong>块内***，从而确保后面的case标签都在变量的</strong>作用域之外</em>*。</li></ul></li></ul></li></ul> <h4 id="迭代语句-循环语句"><a href="#迭代语句-循环语句" class="header-anchor">#</a> 迭代语句（循环语句）</h4> <ul><li>while语句<div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code> <span class="token keyword">while</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span>
    statement           <span class="token comment">//只要condition的求值结果为真就一直执行statement。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li>定义在while条件部分或者while循环体内的变量每次迭代都经历从创建到销毁的过程。</li> <li>使用：当不确定<strong>迭代次数</strong>时，使用while循环比较合适。</li></ul></li> <li>for语句<div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">for</span><span class="token punctuation">(</span>init<span class="token operator">-</span>statement<span class="token punctuation">;</span>condition<span class="token punctuation">;</span>expression<span class="token punctuation">)</span>    <span class="token comment">//init-statement负责初始化一个值</span>
                                            <span class="token comment">//condition作为循环控制的条件，只要condtion为真，就执行一次statement</span>
                                            <span class="token comment">//expression负责修改init-statement的值</span>
  statement
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>init-statement必须是声明语句、表达式语句或者空语句的一种。</li> <li>for语句头中定义的对象只在for循环体内可见</li> <li>for语句能省略init-statement,condition,expression中的任何一个，但是分号必须保留。</li></ul></li> <li>范围for
<ul><li>作用：遍历容器或其他序列的所有元素。</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>  <span class="token keyword">for</span><span class="token punctuation">(</span> declaration <span class="token operator">:</span> expression <span class="token punctuation">)</span>       <span class="token comment">//expression是一个序列，且都拥有能返回迭代器的begin和end成员。</span>
                                        <span class="token comment">//declaration定义一个序列中元素类型的变量。（常使用auto类型转换符）</span>
    statement <span class="token punctuation">;</span>                         <span class="token comment">//迭代语句块</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>范围for只能对序列进行迭代，不能通过statement在序列中添加（删除）元素。</li> <li>例：<div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>  vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment">//定义一个vector&lt;int&gt;变量</span>

  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;</span>r<span class="token operator">:</span> v<span class="token punctuation">)</span>                       <span class="token comment">//使用pass by reference进行写操作</span>
      r<span class="token operator">*=</span><span class="token number">2</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li></ul></li> <li>do while语句<div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>  <span class="token comment">//do while循环先执行循环体，后检查条件</span>
  <span class="token keyword">do</span>
    statement
  <span class="token keyword">while</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//分号表示语句结束</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>因为do while语句先执行语句块，后检查条件，所以不允许在条件部分定义变量。</li></ul></li></ul> <h4 id="跳转语句"><a href="#跳转语句" class="header-anchor">#</a> 跳转语句</h4> <ul><li>break语句：负责终止离它最近的while、do while、for或switch语句，并从这些语句后的第一条语句开始继续执行。（跳出语句块）</li> <li>continue语句：终止最近的循环中的当前迭代并立即开始下一次迭代。
<ul><li>对于while或者do while语句来说，继续判断条件的值</li> <li>对于传统for循环来说，继续执行for语句头的expression</li> <li>对于范围for来说，用序列中的下一个元素初始化循环控制变量</li></ul></li></ul> <h3 id="_6-运算符"><a href="#_6-运算符" class="header-anchor">#</a> 6. 运算符</h3> <ul><li><p>c++运算符基础</p> <blockquote><ol><li>重载运算符：自定义运算符的含义，为已知运算符赋予另外一层含义。</li> <li>括号无视优先级与结合律</li> <li>在表达式求指的过程中，运算对象常常会由一种类型转换成另外一种类型。</li> <li>左值和右值运算符</li></ol></blockquote></li> <li><p>算术运算符</p> <ul><li><table><thead><tr><th>运算符</th> <th>功能</th></tr></thead> <tbody><tr><td>+</td> <td>一元正号</td></tr> <tr><td>-</td> <td>一员负号</td></tr> <tr><td>*</td> <td>乘法</td></tr> <tr><td>/</td> <td>除法</td></tr> <tr><td>%</td> <td>求余</td></tr> <tr><td>+</td> <td>加法</td></tr> <tr><td>-</td> <td>减法</td></tr></tbody></table></li> <li>算术运算符都满足左结合律。</li> <li>一元正号和一元负号运算符，返回运算对象的副本。</li> <li>参加取余运算的运算对象必须是整数类型。</li></ul></li> <li><p>逻辑和关系运算符</p> <ul><li>逻辑运算符
<table><thead><tr><th>运算符</th> <th>功能</th></tr></thead> <tbody><tr><td>！</td> <td>逻辑非</td></tr> <tr><td>&amp;&amp;</td> <td>逻辑与</td></tr> <tr><td>||</td> <td>逻辑或</td></tr> <tr><td>+ 逻辑或（</td> <td></td></tr></tbody></table> <ul><li>逻辑或和逻辑与是<strong>短路求值</strong>的运算符</li> <li>逻辑非(!):将运算对象的值取反后返回。</li></ul></li></ul> <ul><li>关系运算符
<table><thead><tr><th>运算符</th> <th>功能</th></tr></thead> <tbody><tr><td>&lt;</td> <td>小于</td></tr> <tr><td>&lt;=</td> <td>小于等于</td></tr> <tr><td>&gt;</td> <td>大于</td></tr> <tr><td>&gt;=</td> <td>大于等于</td></tr> <tr><td>==</td> <td>相等</td></tr> <tr><td>!=</td> <td>不相等</td></tr></tbody></table> <ul><li>进行比较运算时除非比较的对象是bool类型，非则不要使用bool类型的字面值作为运算对象。</li></ul></li></ul></li> <li><p>赋值运算符(=)</p> <ul><li>赋值运算符的优先级低于关系运算符的优先级，所以在条件语句中，赋值部分应加上括号。</li> <li>切勿混淆相等运算符（==）和赋值运算符</li> <li>复合赋值运算符：使用复合赋值运算符只求值一次，而普通的运算符求值两次。</li></ul></li> <li><p>递增和递减运算符</p> <ul><li>递增（++）和递减（--）运算符为对象加1和减1提供了一种简洁的书写形式。</li> <li>递增（++）和递减（--）运算符都有<strong>前置</strong>和<strong>后置</strong>两种版本。</li> <li>除非必须，否则不用递增递减运算符的后置版本。</li></ul></li> <li><p>成员访问运算符</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>  ptr<span class="token operator">-&gt;</span>mem<span class="token punctuation">;</span>
  <span class="token punctuation">(</span><span class="token operator">*</span>ptr<span class="token punctuation">)</span><span class="token punctuation">.</span>mem<span class="token punctuation">;</span>     <span class="token comment">//这两种形式等价</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li>解引用运算符的优先级低于点运算符。</li> <li>箭头运算符作用于一个指针类型的运算对象，结果是一个左值。</li></ul></li> <li><p>条件运算符</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>  cond <span class="token operator">?</span> expr1 <span class="token operator">:</span> expr2 <span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>cond是判断条件的表达式，expr1和expr2是两个类型相同或可能转换位某个公共类型的表达式。</li> <li>允许条件运算符的内部嵌套另外一个条件运算符。</li> <li>条件运算符优先级非常低，cond一般加括号。</li></ul></li> <li><p>位运算符（❤❤❤）</p> <ul><li>作用：用于整型类型的运算对象，并把运算对象看成是二进制位的集合。
<table><thead><tr><th>运算符</th> <th>功能</th> <th>操作</th></tr></thead> <tbody><tr><td>~</td> <td>位求反</td> <td>逐位求反后生成一个新值</td></tr> <tr><td>&lt;&lt;</td> <td>左移</td> <td>在右侧插入值为0的二进制位</td></tr> <tr><td>&gt;&gt;</td> <td>右移</td> <td></td></tr> <tr><td>&amp;</td> <td>位与</td> <td>两个运算对象对应位都是1，则该位为1</td></tr> <tr><td>|</td> <td>位或</td> <td>两个运算对象对应位至少有一个1，则运算结果为1</td></tr> <tr><td>^</td> <td>位异或</td> <td>两个运算对象对应位不相同时，运算结果为1</td></tr></tbody></table></li></ul></li> <li><p>sizeof运算符（❤❤❤❤）</p> <ul><li>返回一条表达式或者一个类型名字所占的<strong>字节数</strong>。</li> <li>返回的值是<strong>size_t类型</strong>的</li> <li>sizeof运算符的两种形式<div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>  <span class="token keyword">sizeof</span> <span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">sizeof</span> expr<span class="token punctuation">;</span>        <span class="token comment">//返回的是表达式结果类型的大小</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li>sizeof运算符的结果
<ol><li>对char或者类型为char的表达式执行sizeof运算，结果得1。</li> <li>对引用类型执行sizeof运算得到被引用对象所占空间的大小。</li> <li>对指针执行sizeof运算，得到指针本身所占的空间的大小（4）。</li> <li>对解引用指针执行sizeof运算得到指针指向的对象所占空间的大小，指针不需有效。</li> <li>对数组执行sizeof得到整个数组所占空间的大小。等价于对数组中所有的元素各执行一次sizeof的和。</li> <li>对string对象和vector对象执行sizeof运算只返回该类型固定部分的大小，不计算对象中的元素占用了多少空间。</li></ol></li> <li>sizeof不会实际求对象的值，所以可以计算无效指针的大小。</li></ul></li></ul> <h3 id="_7-const限定符"><a href="#_7-const限定符" class="header-anchor">#</a> 7. const限定符</h3> <ul><li><h4 id="const的作用-❤❤❤❤"><a href="#const的作用-❤❤❤❤" class="header-anchor">#</a> const的作用(❤❤❤❤)</h4></li></ul> <ol><li><p>定义常量</p> <ul><li>由oonst限定符修饰的对象是一个常量，不能对其进行赋值操作。</li> <li>const对象必须初始化。</li> <li>格式：<code>const int bufSize = 1 ; //初始值可以是任何复杂的表达式或函 数</code></li></ul></li> <li><p>类型检查</p> <p><strong><code>#define</code>常量和<code>const常量</code>的区别</strong>：</p> <ul><li><code>const常量</code>具有<strong>类型</strong>，编译器可以进行安全检查；</li> <li><code>#define</code>定义没有数据类型，只是简单的字符串替换，不能进行安全检查。</li> <li>const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是像 #define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干个拷贝。</li></ul></li> <li><p>防止修改，增加安全性
const变量不能被修改</p></li></ol> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>  <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>
    i<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//error!</span>
  <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ol start="4"><li><p>可以节省空间，避免不必要的内存分配</p> <p><code>const常量</code>比<code>#define常量</code>占用的内存小。</p></li></ol> <ul><li>默认状态下，const对象仅在文件内有效
<ul><li>如果程序包含多个文件，则每个用了const对象的文件都必须有该const定义。</li> <li>默认情况下，const对象被设定为仅在文件内有效。当多个文件中出现了同名的const变量时，其实等同于在不同文件中分别定了独立的变量。</li> <li>使用<code>extern</code>关键字定义的const变量只需定义一次就可以了。</li> <li>如果想在多个文件之间共享使用<code>const</code>变量，必须在变量的定义之前添加extern关键字。</li></ul></li> <li>const的引用<div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>  <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>r <span class="token operator">=</span> i<span class="token punctuation">;</span>         <span class="token comment">//允许将const int&amp;绑定到一个普通的int对象上</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> ci <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>          <span class="token comment">//定义一个const常量</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>rl <span class="token operator">=</span> ci<span class="token punctuation">;</span>           <span class="token comment">//正确：引用及其对应的对象都是常量</span>
  rl <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>                      <span class="token comment">//错误：rl是对常量的引用，不能修改它绑定的值</span>
  <span class="token keyword">int</span> <span class="token operator">&amp;</span>r2 <span class="token operator">=</span> ci<span class="token punctuation">;</span>                 <span class="token comment">//错误：不能用非常量引用指向一个常量对象</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><ul><li>对const的引用可能引用一个非const的对象</li> <li>对const的引用绑定的变量的值不能修改。</li></ul></li> <li><h4 id="指针和const-❤❤❤❤"><a href="#指针和const-❤❤❤❤" class="header-anchor">#</a> 指针和const（❤❤❤❤）</h4></li> <li>const和指针的四种位置关系<div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>  <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> a<span class="token punctuation">;</span>         <span class="token comment">//指向const对象的指针或者说指向常量的指针。</span>
  <span class="token keyword">char</span> <span class="token keyword">const</span> <span class="token operator">*</span> a<span class="token punctuation">;</span>         <span class="token comment">//等价与上面的形式</span>
  <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token keyword">const</span> a<span class="token punctuation">;</span>         <span class="token comment">//const指针、常量指针。</span>
  <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token keyword">const</span> a<span class="token punctuation">;</span>   <span class="token comment">//指向const对象的const指针。          </span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>const出现在*左边，表示被指的对象是常量，值不可以改变；</li> <li>const出现在*右边，表示指针自身是常量，指针地址不可以改变</li> <li>const出现在*两边，所指对象和指针本身都是常量，值和地址都不可以改变。</li></ul></li> <li>顶层const和底层const（★★★）
<ul><li>顶层const：表示指针本身是一个常量。</li> <li>底层const：表示指针所指的对象是一个常量。</li></ul></li> <li>constexpr和常量表达式
<ul><li>常量表达式：是指值不会改变并且在编译过程就能得到计算结果的表达式。</li> <li>constexp变量：C++11新标准规定，允许将变量声明为constexpr类型以便由<strong>编译器</strong>来验证变量的值是否是一个常量表达式。</li> <li>一个<strong>constexpr指针</strong>的初始值必须是nullptr或者0，或者是存储于某个固定地址中的对象。</li> <li>constexpr既可以指向常量也可以指向一个非常量。</li> <li>constexpr把它所定义的指针置为了顶层const，不能改变所指地址。</li></ul></li></ul> <h3 id="_8-函数"><a href="#_8-函数" class="header-anchor">#</a> 8.函数</h3> <ul><li>函数基础
<ul><li>组成:返回类型、函数姓名、参数列表、函数体。</li> <li>函数的调用：
<ul><li>通过<strong>调用运算符</strong>()来执行函数。</li> <li>运算符之内是一个用逗号隔开的<strong>实参列表</strong>。</li> <li>调用表达式的类型就是函数的<strong>返回类型</strong>。</li></ul></li> <li>函数调用的过程：
<ul><li>实参初始化函数对应的形参；</li> <li><strong>主调函数</strong>暂停执行，<strong>被调函数</strong>开始执行。</li> <li>完成被调函数，遇到<strong>return</strong>语句时函数结束执行。</li></ul></li> <li>return语句的作用：
<ul><li>返回return语句中的值；</li> <li>将程序控制权从被调函数转回主调函数。</li></ul></li> <li>实参是形参的初始值。所以实参的类型必须与对应的形参类型匹配。</li> <li>函数的形参列表可以为空，但是不能省略。可以使用void表示函数没有形参；任意两个形参不能同名。</li> <li>不返回任何值的函数返回类型为void。</li></ul></li> <li>C++语言中，名字有<strong>作用域</strong>，对象有<strong>生命周期</strong> <ul><li>名字的作用域是程序文本的一部分，名字在其中可见。</li> <li>对象的生命周期是程序执行过程中该对象存在的一段时间。</li> <li><strong>局部变量</strong>：形参和函数体内部定义的变量统称为<strong>局部变量</strong>。仅在函数的作用域内可见，函数终止时，形参也会被销毁。</li> <li><strong>自动对象</strong>：只存在于块执行的对象称为自动对象。</li> <li><strong>局部静态变量</strong>：在程序执行路径第一次经过对象定义语句时初始化，并且直到程序终止才被销毁。将局部变量定义为static类型。</li></ul></li> <li>函数声明
<ul><li>函数声明和函数的定义非常类似，唯一的区别是函数声明无须函数体。</li> <li>函数声明（函数原型）包括：返回类型、函数名、形参类型。</li></ul></li> <li><h4 id="函数的参数传递"><a href="#函数的参数传递" class="header-anchor">#</a> 函数的参数传递</h4> <ul><li>每次调用函数都会<strong>重新创建</strong>它的形参，并用传入的实参初始化。</li> <li>形参初始化的机理和变量初始化一样：
<ul><li>pass by reference:如果形参是引用类型，它将绑定到对应的实参上。</li> <li>pass by value:将实参的值拷贝后赋给形参。</li> <li>指针形参：当执行指针拷贝操作时，拷贝的是指针的值。</li></ul></li> <li>传引用参数
<ul><li>使用引用形参，允许函数一个或多个实参的值。</li> <li>当某些类型不支持拷贝操作或者拷贝大的类对象或者容器对象时，函数只能通过引用形参来访问该对象。</li> <li>对于无须改变对象内容的形参，定义为对常量的引用。</li> <li>建议使用引用类型的形参代替指针。</li></ul></li> <li>数组形参
<ul><li>数组的两个性质：不允许拷贝数组；数组名是一个指向数组第一个元素的指针。</li> <li>不能拷贝数组，所有不能对数组进行pass by value</li> <li>当我们为函数传递一个数组时，实际上传递的是指向数组首元素的指针</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>  <span class="token comment">//三个print函数是等价的</span>
  <span class="token comment">//每个函数都有一个const int*类型的形参</span>
  <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>当函数不需要对数组元素进行写操作时，数组形参应该是指向const的指针</li> <li>数组引用：</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>  <span class="token keyword">int</span> <span class="token operator">&amp;</span>arr<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token comment">//arr为含有10个int引用的数组</span>
  <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>arr<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token comment">//arr为具有10个整数的整型数组的引用，其中维度是类型的一部分</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ul></li> <li>返回类型和return语句
<ul><li>return语句终止当前正在执行的函数并将控制权返回到调用该函数的地方。</li> <li>return语句的两种形式：</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>  <span class="token keyword">return</span> <span class="token punctuation">;</span>
  <span class="token keyword">return</span> expression<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li>无返回值函数：没有返回值的return语句只能用在返回类型是void的函数中。这类函数中return可以省略，会隐式地执行return。</li> <li>无返回值的函数可以返回另一个返回void的函数。<code>void()--&gt;void()--&gt;return</code></li> <li>有返回值的函数，return语句返回值必须与函数的返回类型相同，或者能隐式地转换成函数的返回类型。</li> <li>如果函数返回引用，则该引用仅是它所引对象的一个别名。</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>  <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token function">shorterString</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s1<span class="token punctuation">,</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span>s2<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">return</span> s1<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> s2<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> s1 <span class="token operator">:</span> s2 <span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li><strong>不要返回局部对象的引用或指针</strong>：函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不在有效的内存区域。</li> <li>函数可以返回类类型。</li> <li><code>C++11</code>函数可以返回花括号包围的值的列表。如果函数返回内置类型，最多包含一个值，且该值所占空间不大于目标类型的空间；函数返回类类型时，由类本身定义初始值如何使用。</li> <li><strong>主函数main的返回值</strong> <ul><li>主函数可以没有return语句直接结束，编译器会隐式的插入一条返回0的return语句。</li> <li>返回0表示执行成功，返回其他值表示执行失败，非0的含义由机器决定。</li> <li>cstdlib头文件定义了两个预处理变量，分别表示成功与失败。（<code>EXIT_SUCCESS</code>,<code>EXIT_FAILURE</code>)</li> <li>main函数不能调用它自己。</li></ul></li> <li>递归：一个函数调用它自己，不管这种调用是直接的还是间接的。</li> <li><strong>返回数组指针：</strong> <ul><li>因为数组不能被拷贝，所以函数不能返回数组。但是，函数可以返回数组的指针或者引用。可以使用类型别名简化返回数组指针或引用的操作。</li> <li>声明一个返回数组指针的函数
<ul><li>格式</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>  <span class="token function">Type</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">functionname</span><span class="token punctuation">(</span>parameter_list<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span>dimension<span class="token punctuation">]</span>
  <span class="token comment">//Type表示元素的类型，dimension表示数组的维度</span>
  <span class="token comment">//parameter_list表示形参列表</span>
  <span class="token comment">//（*functionname(parameter_list))两端的括号必须存在，否则表示返回指针的数组。</span>

  <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token comment">//返回一个指向大小为10的int数组的指针。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li> <li>使用尾置返回类型</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>  <span class="token comment">//func接受一个int类型的参数，返回一个指针，该指针指向含有10个整数的数组</span>
  <span class="token keyword">auto</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li>使用decltype：如果我们知道函数返回的指针将指向那个数组，就可以使用decltype关键字声明返回类型。<code>decltype(array) *function(parameter_list)</code></li> <li>decltype并不负责把指针转换成对应的指针，所以decltype的结果是个数组。</li></ul></li></ul></li> <li><h4 id="函数重载"><a href="#函数重载" class="header-anchor">#</a> 函数重载</h4> <ul><li>同一作用域内的几个函数的名字相同但是形参列表不同，我们称之为重载函数。</li> <li>main函数不能重载。</li> <li>定义重载函数：
<ul><li>对于重载函数，他们应该在形参数量或形参类型上有所不同。</li> <li>不允许两个函数除了返回类型外其他所有的要素都相同。</li></ul></li> <li>重载和const形参
<ul><li>一个拥有顶层const(所指对象地址不变）的形参无法和另一个没有顶层const的形参区分开来。</li> <li>如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的const是底层(所指对象值不变）的。</li></ul></li> <li>const_cast和重载
<ul><li>const_cast将常量对象转换成非常量对象</li></ul></li> <li>调用重载的函数
<ul><li>函数匹配：把函数调用与一组重载函数中的某一个关联起来</li> <li>调用重载函数的三种可能：
<ul><li>编译器找到一个与实参<strong>最佳匹配</strong>的参数。</li> <li>找不到任何一个函数与调用的实参匹配，此时编译器发出<strong>无匹配</strong>的错误。</li> <li>有多于一个函数可以匹配，但每一个都不是明显的最佳选择，称为<strong>二义性调用</strong>。</li></ul></li></ul></li> <li>重载与作用域：一旦在当前作用域找到了所需的名字，编译器就会忽略掉外层作用域中的同名实体。C++语言中，名字查找发生在类型检查之前。</li></ul></li> <li>三种函数相关的语言特性
<ul><li><strong>默认参数</strong> <ul><li>在函数定义过程中，我们可以为形参提供默认实参。默认实参作为形参的初始值出现在形参列表中。我们可以为一个或多个形参定义默认值，一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值。</li> <li>如果想使用默认实参，只要在调用函数的使用省略该实参就可以了。</li> <li>当设计含有默认实参的函数时，要合理设置形参的顺序，尽量把不怎么使用默认值的形参出现在前面，而让经常使用默认值的形参出现在后面。</li> <li>函数的后续声明只能为之前没有默认值的形参添加默认参数，而且该形参右边的所有形参必须都有默认值。不能修改一个已经存在的默认值。</li> <li>局部变量不能作为默认实参。</li></ul></li> <li><strong>内联函数（inline）</strong> <ul><li>将函数声明为<code>inline</code>只是向编译器发出的请求，编译器可以选择忽略这个请求。</li> <li>内联机制用于优化规模较小、流程直接、频繁调用的函数。</li></ul></li> <li><strong>constexpr函数</strong> <ul><li>constexpr函数是指能用于常量表达式的函数</li> <li>特点：函数的返回类型及所有参数的类型都得是字面值类型，而且函数体中必须有且只有一条return语句。</li> <li>constexpr函数被隐式地指定为内联函数。</li> <li>constexpr函数不一定返回常量表达式。</li></ul></li> <li>内联函数和constexpr函数通常定义在头文件中。</li></ul></li> <li>函数指针
<ul><li>函数指针指向的是函数而非对象。函数指针指向某种特定类型，函数的类型由它的返回类型和形参类型共同决定。</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">//一个比较两个string对象的指针</span>
<span class="token keyword">bool</span> <span class="token function">lengthCompare</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">;</span>
<span class="token comment">//指向lengthCompare函数的指针</span>
<span class="token keyword">bool</span> <span class="token punctuation">(</span><span class="token operator">*</span>pf<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">,</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//*pf两端的括号必不可少，否则pf是一个返回值为bool指针的函数</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>使用函数指针
<ul><li>当我们把函数名作为一个值使用时，该函数自动地转换成指针。</li> <li>我们能直接使用指向函数的指针调用该函数，无须提前解引用指针。</li></ul></li> <li>函数指针形参
<ul><li>不能定义函数类型的形参，但是形参可以是指向函数的指针。</li> <li>我们可以直接把函数作为实参使用，此时它会自动转换为指针。</li> <li>类型别名和decltype可以简化使用了函数指针的代码。</li></ul></li> <li>返回指向函数的指针
<ul><li>虽然不能返回一个函数，但是能返回指向函数类型的指针。</li> <li>和返回数组指针相似，可以使用尾置返回类型的方式，声明一个返回函数指针的函数体。</li></ul></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>  <span class="token comment">//使用类型别名声明 返回指向函数的指针</span>
  <span class="token keyword">using</span> PF <span class="token operator">=</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">//PF是指针类型</span>
  PF <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">//PF是指向函数的指针，f1返回指向函数的指针</span>
  <span class="token comment">//直接声明</span>
  <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//尾置声明</span>
  <span class="token keyword">auto</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>将auto和decltype用于函数指针类型
<ul><li>明确直到返回的函数是哪一个，就能使用<code>decltype</code>简化书写函数指针返回类型的过程，</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>  string<span class="token operator">::</span>size_type <span class="token function">sumLength</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  string<span class="token operator">::</span>size_type <span class="token function">largeLength</span><span class="token punctuation">(</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">,</span><span class="token keyword">const</span> string<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">//根据其形参的取值，getFcn函数返回指向sumLength或者largeLength的指针。</span>
  <span class="token keyword">decltype</span><span class="token punctuation">(</span>sumLength<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token function">getFcn</span><span class="token punctuation">(</span><span class="token keyword">const</span> string <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li> <li>decltype作用于某个函数时，它返回函数类型而非指针类型。因此，我们显示地加上*以表明我们需要返回指针，而非函数本身。</li></ul></li></ul></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/y1s1_blog/assets/js/app.232c4f74.js" defer></script><script src="/y1s1_blog/assets/js/2.2dc00104.js" defer></script><script src="/y1s1_blog/assets/js/7.bd043cd8.js" defer></script>
  </body>
</html>
